/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { TagService } from "../tag.service";
import { TagCreateInput } from "./TagCreateInput";
import { TagWhereInput } from "./TagWhereInput";
import { TagWhereUniqueInput } from "./TagWhereUniqueInput";
import { TagFindManyArgs } from "./TagFindManyArgs";
import { TagUpdateInput } from "./TagUpdateInput";
import { Tag } from "./Tag";
import { TagCandidateFindManyArgs } from "../../tagCandidate/base/TagCandidateFindManyArgs";
import { TagCandidate } from "../../tagCandidate/base/TagCandidate";
import { TagCandidateWhereUniqueInput } from "../../tagCandidate/base/TagCandidateWhereUniqueInput";
import { TagEmployeeFindManyArgs } from "../../tagEmployee/base/TagEmployeeFindManyArgs";
import { TagEmployee } from "../../tagEmployee/base/TagEmployee";
import { TagEmployeeWhereUniqueInput } from "../../tagEmployee/base/TagEmployeeWhereUniqueInput";
import { TagEmployeeLevelFindManyArgs } from "../../tagEmployeeLevel/base/TagEmployeeLevelFindManyArgs";
import { TagEmployeeLevel } from "../../tagEmployeeLevel/base/TagEmployeeLevel";
import { TagEmployeeLevelWhereUniqueInput } from "../../tagEmployeeLevel/base/TagEmployeeLevelWhereUniqueInput";
import { TagEquipmentFindManyArgs } from "../../tagEquipment/base/TagEquipmentFindManyArgs";
import { TagEquipment } from "../../tagEquipment/base/TagEquipment";
import { TagEquipmentWhereUniqueInput } from "../../tagEquipment/base/TagEquipmentWhereUniqueInput";
import { TagEventTypeFindManyArgs } from "../../tagEventType/base/TagEventTypeFindManyArgs";
import { TagEventType } from "../../tagEventType/base/TagEventType";
import { TagEventTypeWhereUniqueInput } from "../../tagEventType/base/TagEventTypeWhereUniqueInput";
import { TagExpenseFindManyArgs } from "../../tagExpense/base/TagExpenseFindManyArgs";
import { TagExpense } from "../../tagExpense/base/TagExpense";
import { TagExpenseWhereUniqueInput } from "../../tagExpense/base/TagExpenseWhereUniqueInput";
import { TagIncomeFindManyArgs } from "../../tagIncome/base/TagIncomeFindManyArgs";
import { TagIncome } from "../../tagIncome/base/TagIncome";
import { TagIncomeWhereUniqueInput } from "../../tagIncome/base/TagIncomeWhereUniqueInput";
import { TagIntegrationFindManyArgs } from "../../tagIntegration/base/TagIntegrationFindManyArgs";
import { TagIntegration } from "../../tagIntegration/base/TagIntegration";
import { TagIntegrationWhereUniqueInput } from "../../tagIntegration/base/TagIntegrationWhereUniqueInput";
import { TagInvoiceFindManyArgs } from "../../tagInvoice/base/TagInvoiceFindManyArgs";
import { TagInvoice } from "../../tagInvoice/base/TagInvoice";
import { TagInvoiceWhereUniqueInput } from "../../tagInvoice/base/TagInvoiceWhereUniqueInput";
import { TagMerchantFindManyArgs } from "../../tagMerchant/base/TagMerchantFindManyArgs";
import { TagMerchant } from "../../tagMerchant/base/TagMerchant";
import { TagMerchantWhereUniqueInput } from "../../tagMerchant/base/TagMerchantWhereUniqueInput";
import { TagOrganizationFindManyArgs } from "../../tagOrganization/base/TagOrganizationFindManyArgs";
import { TagOrganization } from "../../tagOrganization/base/TagOrganization";
import { TagOrganizationWhereUniqueInput } from "../../tagOrganization/base/TagOrganizationWhereUniqueInput";
import { TagOrganizationContactFindManyArgs } from "../../tagOrganizationContact/base/TagOrganizationContactFindManyArgs";
import { TagOrganizationContact } from "../../tagOrganizationContact/base/TagOrganizationContact";
import { TagOrganizationContactWhereUniqueInput } from "../../tagOrganizationContact/base/TagOrganizationContactWhereUniqueInput";
import { TagOrganizationDepartmentFindManyArgs } from "../../tagOrganizationDepartment/base/TagOrganizationDepartmentFindManyArgs";
import { TagOrganizationDepartment } from "../../tagOrganizationDepartment/base/TagOrganizationDepartment";
import { TagOrganizationDepartmentWhereUniqueInput } from "../../tagOrganizationDepartment/base/TagOrganizationDepartmentWhereUniqueInput";
import { TagOrganizationEmploymentTypeFindManyArgs } from "../../tagOrganizationEmploymentType/base/TagOrganizationEmploymentTypeFindManyArgs";
import { TagOrganizationEmploymentType } from "../../tagOrganizationEmploymentType/base/TagOrganizationEmploymentType";
import { TagOrganizationEmploymentTypeWhereUniqueInput } from "../../tagOrganizationEmploymentType/base/TagOrganizationEmploymentTypeWhereUniqueInput";
import { TagOrganizationExpenseCategoryFindManyArgs } from "../../tagOrganizationExpenseCategory/base/TagOrganizationExpenseCategoryFindManyArgs";
import { TagOrganizationExpenseCategory } from "../../tagOrganizationExpenseCategory/base/TagOrganizationExpenseCategory";
import { TagOrganizationExpenseCategoryWhereUniqueInput } from "../../tagOrganizationExpenseCategory/base/TagOrganizationExpenseCategoryWhereUniqueInput";
import { TagOrganizationPositionFindManyArgs } from "../../tagOrganizationPosition/base/TagOrganizationPositionFindManyArgs";
import { TagOrganizationPosition } from "../../tagOrganizationPosition/base/TagOrganizationPosition";
import { TagOrganizationPositionWhereUniqueInput } from "../../tagOrganizationPosition/base/TagOrganizationPositionWhereUniqueInput";
import { TagOrganizationProjectFindManyArgs } from "../../tagOrganizationProject/base/TagOrganizationProjectFindManyArgs";
import { TagOrganizationProject } from "../../tagOrganizationProject/base/TagOrganizationProject";
import { TagOrganizationProjectWhereUniqueInput } from "../../tagOrganizationProject/base/TagOrganizationProjectWhereUniqueInput";
import { TagOrganizationTeamFindManyArgs } from "../../tagOrganizationTeam/base/TagOrganizationTeamFindManyArgs";
import { TagOrganizationTeam } from "../../tagOrganizationTeam/base/TagOrganizationTeam";
import { TagOrganizationTeamWhereUniqueInput } from "../../tagOrganizationTeam/base/TagOrganizationTeamWhereUniqueInput";
import { TagOrganizationVendorFindManyArgs } from "../../tagOrganizationVendor/base/TagOrganizationVendorFindManyArgs";
import { TagOrganizationVendor } from "../../tagOrganizationVendor/base/TagOrganizationVendor";
import { TagOrganizationVendorWhereUniqueInput } from "../../tagOrganizationVendor/base/TagOrganizationVendorWhereUniqueInput";
import { TagPaymentFindManyArgs } from "../../tagPayment/base/TagPaymentFindManyArgs";
import { TagPayment } from "../../tagPayment/base/TagPayment";
import { TagPaymentWhereUniqueInput } from "../../tagPayment/base/TagPaymentWhereUniqueInput";
import { TagProductFindManyArgs } from "../../tagProduct/base/TagProductFindManyArgs";
import { TagProduct } from "../../tagProduct/base/TagProduct";
import { TagProductWhereUniqueInput } from "../../tagProduct/base/TagProductWhereUniqueInput";
import { TagProposalFindManyArgs } from "../../tagProposal/base/TagProposalFindManyArgs";
import { TagProposal } from "../../tagProposal/base/TagProposal";
import { TagProposalWhereUniqueInput } from "../../tagProposal/base/TagProposalWhereUniqueInput";
import { TagRequestApprovalFindManyArgs } from "../../tagRequestApproval/base/TagRequestApprovalFindManyArgs";
import { TagRequestApproval } from "../../tagRequestApproval/base/TagRequestApproval";
import { TagRequestApprovalWhereUniqueInput } from "../../tagRequestApproval/base/TagRequestApprovalWhereUniqueInput";
import { TagTaskFindManyArgs } from "../../tagTask/base/TagTaskFindManyArgs";
import { TagTask } from "../../tagTask/base/TagTask";
import { TagTaskWhereUniqueInput } from "../../tagTask/base/TagTaskWhereUniqueInput";
import { TagUserFindManyArgs } from "../../tagUser/base/TagUserFindManyArgs";
import { TagUser } from "../../tagUser/base/TagUser";
import { TagUserWhereUniqueInput } from "../../tagUser/base/TagUserWhereUniqueInput";
import { TagWarehouseFindManyArgs } from "../../tagWarehouse/base/TagWarehouseFindManyArgs";
import { TagWarehouse } from "../../tagWarehouse/base/TagWarehouse";
import { TagWarehouseWhereUniqueInput } from "../../tagWarehouse/base/TagWarehouseWhereUniqueInput";

export class TagControllerBase {
  constructor(protected readonly service: TagService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Tag })
  async create(@common.Body() data: TagCreateInput): Promise<Tag> {
    return await this.service.create({
      data: {
        ...data,

        organizationTeam: data.organizationTeam
          ? {
              connect: data.organizationTeam,
            }
          : undefined,

        tenant: data.tenant
          ? {
              connect: data.tenant,
            }
          : undefined,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,
      },
      select: {
        updatedAt: true,
        name: true,
        id: true,
        createdAt: true,
        description: true,
        color: true,
        isSystem: true,
        icon: true,

        organizationTeam: {
          select: {
            id: true,
          },
        },

        tenant: {
          select: {
            id: true,
          },
        },

        organization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [Tag] })
  @ApiNestedQuery(TagFindManyArgs)
  async findMany(@common.Req() request: Request): Promise<Tag[]> {
    const args = plainToClass(TagFindManyArgs, request.query);
    return this.service.findMany({
      ...args,
      select: {
        updatedAt: true,
        name: true,
        id: true,
        createdAt: true,
        description: true,
        color: true,
        isSystem: true,
        icon: true,

        organizationTeam: {
          select: {
            id: true,
          },
        },

        tenant: {
          select: {
            id: true,
          },
        },

        organization: {
          select: {
            id: true,
          },
        },
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Tag })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async findOne(
    @common.Param() params: TagWhereUniqueInput
  ): Promise<Tag | null> {
    const result = await this.service.findOne({
      where: params,
      select: {
        updatedAt: true,
        name: true,
        id: true,
        createdAt: true,
        description: true,
        color: true,
        isSystem: true,
        icon: true,

        organizationTeam: {
          select: {
            id: true,
          },
        },

        tenant: {
          select: {
            id: true,
          },
        },

        organization: {
          select: {
            id: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Tag })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async update(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() data: TagUpdateInput
  ): Promise<Tag | null> {
    try {
      return await this.service.update({
        where: params,
        data: {
          ...data,

          organizationTeam: data.organizationTeam
            ? {
                connect: data.organizationTeam,
              }
            : undefined,

          tenant: data.tenant
            ? {
                connect: data.tenant,
              }
            : undefined,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,
        },
        select: {
          updatedAt: true,
          name: true,
          id: true,
          createdAt: true,
          description: true,
          color: true,
          isSystem: true,
          icon: true,

          organizationTeam: {
            select: {
              id: true,
            },
          },

          tenant: {
            select: {
              id: true,
            },
          },

          organization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Tag })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async delete(
    @common.Param() params: TagWhereUniqueInput
  ): Promise<Tag | null> {
    try {
      return await this.service.delete({
        where: params,
        select: {
          updatedAt: true,
          name: true,
          id: true,
          createdAt: true,
          description: true,
          color: true,
          isSystem: true,
          icon: true,

          organizationTeam: {
            select: {
              id: true,
            },
          },

          tenant: {
            select: {
              id: true,
            },
          },

          organization: {
            select: {
              id: true,
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Get("/:id/tagCandidate")
  @ApiNestedQuery(TagCandidateFindManyArgs)
  async findManyTagCandidate(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagCandidate[]> {
    const query = plainToClass(TagCandidateFindManyArgs, request.query);
    const results = await this.service.findTagCandidate(params.id, {
      ...query,
      select: {
        candidate: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagCandidate")
  async connectTagCandidate(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagCandidateWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagCandidate: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagCandidate")
  async updateTagCandidate(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagCandidateWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagCandidate: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagCandidate")
  async disconnectTagCandidate(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagCandidateWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagCandidate: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagEmployee")
  @ApiNestedQuery(TagEmployeeFindManyArgs)
  async findManyTagEmployee(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagEmployee[]> {
    const query = plainToClass(TagEmployeeFindManyArgs, request.query);
    const results = await this.service.findTagEmployee(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        employee: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagEmployee")
  async connectTagEmployee(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployee: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagEmployee")
  async updateTagEmployee(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployee: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagEmployee")
  async disconnectTagEmployee(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployee: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagEmployeeLevel")
  @ApiNestedQuery(TagEmployeeLevelFindManyArgs)
  async findManyTagEmployeeLevel(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagEmployeeLevel[]> {
    const query = plainToClass(TagEmployeeLevelFindManyArgs, request.query);
    const results = await this.service.findTagEmployeeLevel(params.id, {
      ...query,
      select: {
        employeeLevel: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagEmployeeLevel")
  async connectTagEmployeeLevel(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeLevelWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployeeLevel: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagEmployeeLevel")
  async updateTagEmployeeLevel(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeLevelWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployeeLevel: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagEmployeeLevel")
  async disconnectTagEmployeeLevel(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEmployeeLevelWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEmployeeLevel: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagEquipment")
  @ApiNestedQuery(TagEquipmentFindManyArgs)
  async findManyTagEquipment(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagEquipment[]> {
    const query = plainToClass(TagEquipmentFindManyArgs, request.query);
    const results = await this.service.findTagEquipment(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        equipment: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagEquipment")
  async connectTagEquipment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEquipmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEquipment: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagEquipment")
  async updateTagEquipment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEquipmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEquipment: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagEquipment")
  async disconnectTagEquipment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEquipmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEquipment: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagEventType")
  @ApiNestedQuery(TagEventTypeFindManyArgs)
  async findManyTagEventType(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagEventType[]> {
    const query = plainToClass(TagEventTypeFindManyArgs, request.query);
    const results = await this.service.findTagEventType(params.id, {
      ...query,
      select: {
        eventType: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagEventType")
  async connectTagEventType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEventType: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagEventType")
  async updateTagEventType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEventType: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagEventType")
  async disconnectTagEventType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagEventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagEventType: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagExpense")
  @ApiNestedQuery(TagExpenseFindManyArgs)
  async findManyTagExpense(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagExpense[]> {
    const query = plainToClass(TagExpenseFindManyArgs, request.query);
    const results = await this.service.findTagExpense(params.id, {
      ...query,
      select: {
        expense: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagExpense")
  async connectTagExpense(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagExpenseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagExpense: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagExpense")
  async updateTagExpense(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagExpenseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagExpense: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagExpense")
  async disconnectTagExpense(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagExpenseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagExpense: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagIncome")
  @ApiNestedQuery(TagIncomeFindManyArgs)
  async findManyTagIncome(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagIncome[]> {
    const query = plainToClass(TagIncomeFindManyArgs, request.query);
    const results = await this.service.findTagIncome(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        income: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagIncome")
  async connectTagIncome(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIncomeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIncome: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagIncome")
  async updateTagIncome(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIncomeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIncome: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagIncome")
  async disconnectTagIncome(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIncomeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIncome: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagIntegration")
  @ApiNestedQuery(TagIntegrationFindManyArgs)
  async findManyTagIntegration(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagIntegration[]> {
    const query = plainToClass(TagIntegrationFindManyArgs, request.query);
    const results = await this.service.findTagIntegration(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        integration: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagIntegration")
  async connectTagIntegration(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIntegrationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIntegration: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagIntegration")
  async updateTagIntegration(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIntegrationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIntegration: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagIntegration")
  async disconnectTagIntegration(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagIntegrationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagIntegration: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagInvoice")
  @ApiNestedQuery(TagInvoiceFindManyArgs)
  async findManyTagInvoice(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagInvoice[]> {
    const query = plainToClass(TagInvoiceFindManyArgs, request.query);
    const results = await this.service.findTagInvoice(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        invoice: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagInvoice")
  async connectTagInvoice(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagInvoiceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagInvoice: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagInvoice")
  async updateTagInvoice(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagInvoiceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagInvoice: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagInvoice")
  async disconnectTagInvoice(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagInvoiceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagInvoice: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagMerchant")
  @ApiNestedQuery(TagMerchantFindManyArgs)
  async findManyTagMerchant(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagMerchant[]> {
    const query = plainToClass(TagMerchantFindManyArgs, request.query);
    const results = await this.service.findTagMerchant(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        merchant: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagMerchant")
  async connectTagMerchant(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagMerchantWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagMerchant: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagMerchant")
  async updateTagMerchant(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagMerchantWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagMerchant: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagMerchant")
  async disconnectTagMerchant(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagMerchantWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagMerchant: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganization")
  @ApiNestedQuery(TagOrganizationFindManyArgs)
  async findManyTagOrganization(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganization[]> {
    const query = plainToClass(TagOrganizationFindManyArgs, request.query);
    const results = await this.service.findTagOrganization(params.id, {
      ...query,
      select: {
        organization: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganization")
  async connectTagOrganization(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganization: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganization")
  async updateTagOrganization(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganization: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganization")
  async disconnectTagOrganization(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganization: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationContact")
  @ApiNestedQuery(TagOrganizationContactFindManyArgs)
  async findManyTagOrganizationContact(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationContact[]> {
    const query = plainToClass(
      TagOrganizationContactFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationContact(params.id, {
      ...query,
      select: {
        organizationContact: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationContact")
  async connectTagOrganizationContact(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationContactWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationContact: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationContact")
  async updateTagOrganizationContact(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationContactWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationContact: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationContact")
  async disconnectTagOrganizationContact(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationContactWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationContact: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationDepartment")
  @ApiNestedQuery(TagOrganizationDepartmentFindManyArgs)
  async findManyTagOrganizationDepartment(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationDepartment[]> {
    const query = plainToClass(
      TagOrganizationDepartmentFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationDepartment(
      params.id,
      {
        ...query,
        select: {
          tag: {
            select: {
              id: true,
            },
          },

          organizationDepartment: {
            select: {
              id: true,
            },
          },

          id: true,
        },
      }
    );
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationDepartment")
  async connectTagOrganizationDepartment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationDepartmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationDepartment: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationDepartment")
  async updateTagOrganizationDepartment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationDepartmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationDepartment: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationDepartment")
  async disconnectTagOrganizationDepartment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationDepartmentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationDepartment: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationEmploymentType")
  @ApiNestedQuery(TagOrganizationEmploymentTypeFindManyArgs)
  async findManyTagOrganizationEmploymentType(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationEmploymentType[]> {
    const query = plainToClass(
      TagOrganizationEmploymentTypeFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationEmploymentType(
      params.id,
      {
        ...query,
        select: {
          organizationEmploymentType: {
            select: {
              id: true,
            },
          },

          tag: {
            select: {
              id: true,
            },
          },

          id: true,
        },
      }
    );
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationEmploymentType")
  async connectTagOrganizationEmploymentType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationEmploymentTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationEmploymentType: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationEmploymentType")
  async updateTagOrganizationEmploymentType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationEmploymentTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationEmploymentType: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationEmploymentType")
  async disconnectTagOrganizationEmploymentType(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationEmploymentTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationEmploymentType: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationExpenseCategory")
  @ApiNestedQuery(TagOrganizationExpenseCategoryFindManyArgs)
  async findManyTagOrganizationExpenseCategory(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationExpenseCategory[]> {
    const query = plainToClass(
      TagOrganizationExpenseCategoryFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationExpenseCategory(
      params.id,
      {
        ...query,
        select: {
          expenseCategory: {
            select: {
              id: true,
            },
          },

          tag: {
            select: {
              id: true,
            },
          },

          id: true,
        },
      }
    );
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationExpenseCategory")
  async connectTagOrganizationExpenseCategory(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationExpenseCategoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationExpenseCategory: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationExpenseCategory")
  async updateTagOrganizationExpenseCategory(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationExpenseCategoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationExpenseCategory: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationExpenseCategory")
  async disconnectTagOrganizationExpenseCategory(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationExpenseCategoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationExpenseCategory: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationPosition")
  @ApiNestedQuery(TagOrganizationPositionFindManyArgs)
  async findManyTagOrganizationPosition(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationPosition[]> {
    const query = plainToClass(
      TagOrganizationPositionFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationPosition(params.id, {
      ...query,
      select: {
        organizationPosition: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationPosition")
  async connectTagOrganizationPosition(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationPositionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationPosition: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationPosition")
  async updateTagOrganizationPosition(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationPositionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationPosition: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationPosition")
  async disconnectTagOrganizationPosition(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationPositionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationPosition: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationProject")
  @ApiNestedQuery(TagOrganizationProjectFindManyArgs)
  async findManyTagOrganizationProject(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationProject[]> {
    const query = plainToClass(
      TagOrganizationProjectFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationProject(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        organizationProject: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationProject")
  async connectTagOrganizationProject(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationProjectWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationProject: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationProject")
  async updateTagOrganizationProject(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationProjectWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationProject: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationProject")
  async disconnectTagOrganizationProject(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationProjectWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationProject: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationTeam")
  @ApiNestedQuery(TagOrganizationTeamFindManyArgs)
  async findManyTagOrganizationTeam(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationTeam[]> {
    const query = plainToClass(TagOrganizationTeamFindManyArgs, request.query);
    const results = await this.service.findTagOrganizationTeam(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        organizationTeam: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationTeam")
  async connectTagOrganizationTeam(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationTeamWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationTeam: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationTeam")
  async updateTagOrganizationTeam(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationTeamWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationTeam: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationTeam")
  async disconnectTagOrganizationTeam(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationTeamWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationTeam: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagOrganizationVendor")
  @ApiNestedQuery(TagOrganizationVendorFindManyArgs)
  async findManyTagOrganizationVendor(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagOrganizationVendor[]> {
    const query = plainToClass(
      TagOrganizationVendorFindManyArgs,
      request.query
    );
    const results = await this.service.findTagOrganizationVendor(params.id, {
      ...query,
      select: {
        organizationVendor: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagOrganizationVendor")
  async connectTagOrganizationVendor(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationVendorWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationVendor: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagOrganizationVendor")
  async updateTagOrganizationVendor(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationVendorWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationVendor: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagOrganizationVendor")
  async disconnectTagOrganizationVendor(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagOrganizationVendorWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagOrganizationVendor: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagPayment")
  @ApiNestedQuery(TagPaymentFindManyArgs)
  async findManyTagPayment(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagPayment[]> {
    const query = plainToClass(TagPaymentFindManyArgs, request.query);
    const results = await this.service.findTagPayment(params.id, {
      ...query,
      select: {
        payment: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagPayment")
  async connectTagPayment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagPaymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagPayment: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagPayment")
  async updateTagPayment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagPaymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagPayment: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagPayment")
  async disconnectTagPayment(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagPaymentWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagPayment: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagProduct")
  @ApiNestedQuery(TagProductFindManyArgs)
  async findManyTagProduct(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagProduct[]> {
    const query = plainToClass(TagProductFindManyArgs, request.query);
    const results = await this.service.findTagProduct(params.id, {
      ...query,
      select: {
        product: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagProduct")
  async connectTagProduct(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProductWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProduct: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagProduct")
  async updateTagProduct(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProductWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProduct: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagProduct")
  async disconnectTagProduct(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProductWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProduct: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagProposal")
  @ApiNestedQuery(TagProposalFindManyArgs)
  async findManyTagProposal(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagProposal[]> {
    const query = plainToClass(TagProposalFindManyArgs, request.query);
    const results = await this.service.findTagProposal(params.id, {
      ...query,
      select: {
        proposal: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagProposal")
  async connectTagProposal(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProposalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProposal: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagProposal")
  async updateTagProposal(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProposalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProposal: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagProposal")
  async disconnectTagProposal(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagProposalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagProposal: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagRequestApproval")
  @ApiNestedQuery(TagRequestApprovalFindManyArgs)
  async findManyTagRequestApproval(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagRequestApproval[]> {
    const query = plainToClass(TagRequestApprovalFindManyArgs, request.query);
    const results = await this.service.findTagRequestApproval(params.id, {
      ...query,
      select: {
        tag: {
          select: {
            id: true,
          },
        },

        requestApproval: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagRequestApproval")
  async connectTagRequestApproval(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagRequestApprovalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagRequestApproval: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagRequestApproval")
  async updateTagRequestApproval(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagRequestApprovalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagRequestApproval: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagRequestApproval")
  async disconnectTagRequestApproval(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagRequestApprovalWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagRequestApproval: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagTask")
  @ApiNestedQuery(TagTaskFindManyArgs)
  async findManyTagTask(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagTask[]> {
    const query = plainToClass(TagTaskFindManyArgs, request.query);
    const results = await this.service.findTagTask(params.id, {
      ...query,
      select: {
        task: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagTask")
  async connectTagTask(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagTaskWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagTask: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagTask")
  async updateTagTask(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagTaskWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagTask: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagTask")
  async disconnectTagTask(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagTaskWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagTask: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagUser")
  @ApiNestedQuery(TagUserFindManyArgs)
  async findManyTagUser(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagUser[]> {
    const query = plainToClass(TagUserFindManyArgs, request.query);
    const results = await this.service.findTagUser(params.id, {
      ...query,
      select: {
        user: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagUser")
  async connectTagUser(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagUserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagUser: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagUser")
  async updateTagUser(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagUserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagUser: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagUser")
  async disconnectTagUser(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagUserWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagUser: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/tagWarehouse")
  @ApiNestedQuery(TagWarehouseFindManyArgs)
  async findManyTagWarehouse(
    @common.Req() request: Request,
    @common.Param() params: TagWhereUniqueInput
  ): Promise<TagWarehouse[]> {
    const query = plainToClass(TagWarehouseFindManyArgs, request.query);
    const results = await this.service.findTagWarehouse(params.id, {
      ...query,
      select: {
        warehouse: {
          select: {
            id: true,
          },
        },

        tag: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/tagWarehouse")
  async connectTagWarehouse(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagWarehouseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagWarehouse: {
        connect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/tagWarehouse")
  async updateTagWarehouse(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagWarehouseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagWarehouse: {
        set: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/tagWarehouse")
  async disconnectTagWarehouse(
    @common.Param() params: TagWhereUniqueInput,
    @common.Body() body: TagWarehouseWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      tagWarehouse: {
        disconnect: body,
      },
    };
    await this.service.update({
      where: params,
      data,
      select: { id: true },
    });
  }
}
